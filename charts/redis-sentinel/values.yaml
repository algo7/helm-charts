# -- Overrides the name of the chart. So it becomes release-name-<nameOverride> instead of release-name-chart-name.
nameOverride: ""

# -- Overrides the full name of the chart. So it becomes <fullnameOverride>
fullnameOverride: ""

redisSecret:
  # -- The name of the secret that contains the Redis password. This secret must exist in the same namespace as the chart is being deployed to. The key that contains the password must be "redis-password".
  name: redis-secret
  # -- The key in the secret that contains the Redis password.
  key: redis-password


redis:
  # -- Number of Redis nodes to deploy. This is a StatefulSet so it must be 1 or the multiple of 2 plus 1 (3, 5, 7, etc).
  replicaCount: 3

  image:
    # -- The repository to pull the image from.
    repository: redis
    # -- The image pull policy. One of Always, IfNotPresent, or Never.
    pullPolicy: IfNotPresent
    # -- Overrides the image tag whose default is the chart appVersion.
    tag: ""

  # -- This is for the secrets for pulling an image from a private repository. It's likely that you won't need to change this.
  imagePullSecrets: []


  serviceAccount:
    # -- Specifies whether a service account should be created. It's a security best practice to create a dedicated service account for each application. If create is set to false, then the default service account will be used which is not recommended.
    create: true
    # -- Automatically mount a ServiceAccount token for the pod
    automount: true
    # -- Annotations to add to the service account
    annotations: {}
    # -- The name of the service account to use. If not set and create is true, a name will be the fullname of the chart (release-name-chart-name)-redis.
    name: ""


  # -- Add custom annotations to the pod.
  podAnnotations: {}

  # -- Add custom labels to the pod.
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000


  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # -- The node selector for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  # -- Affinity for pod assignment
  affinity: {}

  # -- The cluster domain for the Kubernetes cluster. Usually this is cluster.local, but if you have a custom domain you can set it here.
  clusterDomain: cluster.local


  persistence:
    # -- Enable persistence using a PersistentVolumeClaim. If false, an emptyDir volume is used which means all data will be lost when the pod is removed or restarted.
    enabled: false
    # -- If you want to use an existing claim, specify the claim name here. If this is set, the other settings for dynamic provisioning are ignored.
    existingClaim: ""
    # -- StorageClass for dynamically provisioned PersistentVolume. If persistence.existingClaim is set, these values are ignored.
    storageClassName: "standard"
    # -- Access mode for the PersistentVolumeClaim. If persistence.existingClaim is set, these values are ignored.
    accessModes:
      - ReadWriteOnce
    # -- Size of the PersistentVolume. If persistence.existingClaim is set, these values are ignored.
    size: 10Gi

haproxy:
  # -- Number of Redis nodes to deploy. This is a StatefulSet so it must be 1 or the multiple of 2 plus 1 (3, 5, 7, etc).
  replicaCount: 3

  image:
    # -- The repository to pull the image from.
    repository: haproxy
    # -- The image pull policy. One of Always, IfNotPresent, or Never.
    pullPolicy: IfNotPresent
    # -- The image tag. There is no default value so you must set this.
    tag: "3.1.8-alpine"

  # -- This is for the secrets for pulling an image from a private repository. It's likely that you won't need to change this.
  imagePullSecrets: []

  serviceAccount:
    # -- Specifies whether a service account should be created. It's a security best practice to create a dedicated service account for each application. If create is set to false, then the default service account will be used which is not recommended.
    create: true
    # -- Automatically mount a ServiceAccount token for the pod
    automount: true
    # -- Annotations to add to the service account
    annotations: {}
    # -- The name of the service account to use. If not set and create is true, a name will be the fullname of the chart (release-name-chart-name)-redis.
    name: ""


  # -- Add custom annotations to the pod.
  podAnnotations: {}

  # -- Add custom labels to the pod.
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000


  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  service:
    # -- Kubernetes Service type. Supported options are ClusterIP, NodePort, and LoadBalancer. You will likely use either LoadBalancer or NodePort.
    type: LoadBalancer
    # -- The port the service will be exposed on. This is independent of the container port which is will always be 2456, 2457, and 2458. This will be the port you connect to. There will be 2 additional ports opened for game traffic. It's the port here +1 and +2. So if you set this to 2456, the ports opened will be 2456, 2457, and 2458. It's templated in the chart to make this easier.
    port: 6379

  # -- The node selector for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  # -- Affinity for pod assignment
  affinity: {}